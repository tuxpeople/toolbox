#!/usr/bin/env python3

"""
Script: serve_this
Zweck: Schneller HTTPS-Server f√ºr lokale Entwicklung und File-Sharing
Verwendung: ./serve_this [options]
"""

import argparse
import os
import ssl
import sys
import tempfile
import subprocess
import socket
import signal
import atexit
from http.server import HTTPServer, SimpleHTTPRequestHandler
from pathlib import Path

# Farben f√ºr Terminal-Output
class Colors:
    BLUE = '\033[0;34m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    RED = '\033[0;31m'
    MAGENTA = '\033[0;35m'
    NC = '\033[0m'  # No Color

def log_info(message):
    print(f"{Colors.BLUE}[INFO]{Colors.NC} {message}")

def log_success(message):
    print(f"{Colors.GREEN}[SUCCESS]{Colors.NC} {message}")

def log_warn(message):
    print(f"{Colors.YELLOW}[WARN]{Colors.NC} {message}")

def log_error(message):
    print(f"{Colors.RED}[ERROR]{Colors.NC} {message}")

class SecureHTTPRequestHandler(SimpleHTTPRequestHandler):
    """Erweiterte Request Handler Klasse"""
    
    def __init__(self, *args, directory=None, **kwargs):
        if directory is None:
            directory = os.getcwd()
        self.directory = directory
        super().__init__(*args, **kwargs)
    
    def log_message(self, format, *args):
        """Custom Logging f√ºr Requests"""
        log_info(f"{self.address_string()} - {format % args}")
    
    def end_headers(self):
        """F√ºge Security Headers hinzu"""
        self.send_header('X-Content-Type-Options', 'nosniff')
        self.send_header('X-Frame-Options', 'DENY')
        self.send_header('X-XSS-Protection', '1; mode=block')
        super().end_headers()

def generate_self_signed_cert(cert_file, key_file, subject="/C=DE/ST=DEV/L=Local/O=DevServer/CN=localhost"):
    """Generiert selbstsigniertes SSL-Zertifikat"""
    
    log_info("Generiere selbstsigniertes SSL-Zertifikat...")
    
    cmd = [
        'openssl', 'req', '-nodes', '-x509', '-newkey', 'rsa:2048',
        '-keyout', key_file,
        '-out', cert_file,
        '-days', '365',
        '-subj', subject
    ]
    
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        log_success(f"SSL-Zertifikat erstellt: {cert_file}")
        return True
    except subprocess.CalledProcessError as e:
        log_error(f"Fehler beim Erstellen des SSL-Zertifikats: {e}")
        log_error(f"OpenSSL Output: {e.stderr}")
        return False
    except FileNotFoundError:
        log_error("OpenSSL nicht gefunden. Bitte installieren:")
        log_info("  macOS: brew install openssl")
        log_info("  Ubuntu/Debian: sudo apt-get install openssl")
        return False

def check_dependencies():
    """Pr√ºft erforderliche Abh√§ngigkeiten"""
    missing_deps = []
    
    # OpenSSL pr√ºfen
    try:
        subprocess.run(['openssl', 'version'], capture_output=True, check=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        missing_deps.append("openssl")
    
    if missing_deps:
        log_error(f"Fehlende Abh√§ngigkeiten: {', '.join(missing_deps)}")
        return False
    
    return True

def cleanup_files(*files):
    """R√§umt tempor√§re Dateien auf"""
    for file_path in files:
        try:
            if file_path and os.path.exists(file_path):
                os.remove(file_path)
                log_info(f"Tempor√§re Datei gel√∂scht: {file_path}")
        except OSError as e:
            log_warn(f"Konnte Datei nicht l√∂schen {file_path}: {e}")

def signal_handler(signum, frame, cleanup_func):
    """Signal Handler f√ºr sauberes Beenden"""
    log_info("Server wird beendet...")
    cleanup_func()
    sys.exit(0)

def get_local_ip():
    """Ermittelt lokale IP-Adresse"""
    try:
        # Verbindung zu externer IP simulieren um lokale IP zu ermitteln
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
            s.connect(("8.8.8.8", 80))
            return s.getsockname()[0]
    except Exception:
        return "127.0.0.1"

def serve_directory(directory, port, interface, use_ssl, cert_file=None, key_file=None, 
                   subject=None, cleanup_certs=True, verbose=False):
    """Startet den HTTP/HTTPS Server"""
    
    # Verzeichnis validieren
    if not os.path.isdir(directory):
        log_error(f"Verzeichnis nicht gefunden: {directory}")
        return False
    
    log_info(f"Serviere Verzeichnis: {os.path.abspath(directory)}")
    
    # Request Handler mit Verzeichnis konfigurieren
    handler = lambda *args, **kwargs: SecureHTTPRequestHandler(*args, directory=directory, **kwargs)
    
    try:
        # HTTP-Server erstellen
        httpd = HTTPServer((interface, port), handler)
        
        # SSL konfigurieren falls gew√ºnscht
        temp_cert = None
        temp_key = None
        
        if use_ssl:
            if cert_file and key_file:
                # Vorhandene Zertifikate verwenden
                if not (os.path.exists(cert_file) and os.path.exists(key_file)):
                    log_error(f"Zertifikatsdateien nicht gefunden: {cert_file}, {key_file}")
                    return False
                final_cert = cert_file
                final_key = key_file
                cleanup_certs = False  # Vorhandene Zerts nicht l√∂schen
            else:
                # Tempor√§re Zertifikate erstellen
                temp_cert = tempfile.NamedTemporaryFile(suffix='.pem', delete=False).name
                temp_key = tempfile.NamedTemporaryFile(suffix='.pem', delete=False).name
                
                if not generate_self_signed_cert(temp_cert, temp_key, subject or "/C=DE/ST=DEV/L=Local/O=DevServer/CN=localhost"):
                    cleanup_files(temp_cert, temp_key)
                    return False
                
                final_cert = temp_cert
                final_key = temp_key
            
            # SSL-Context erstellen
            try:
                ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
                ssl_context.check_hostname = False
                ssl_context.load_cert_chain(certfile=final_cert, keyfile=final_key)
                httpd.socket = ssl_context.wrap_socket(httpd.socket, server_side=True)
                protocol = "HTTPS"
            except Exception as e:
                log_error(f"SSL-Konfiguration fehlgeschlagen: {e}")
                if cleanup_certs:
                    cleanup_files(temp_cert, temp_key)
                return False
        else:
            protocol = "HTTP"
        
        # Cleanup-Funktion f√ºr Signal Handler
        def cleanup():
            if cleanup_certs:
                cleanup_files(temp_cert, temp_key)
        
        # Signal Handler registrieren
        signal.signal(signal.SIGINT, lambda s, f: signal_handler(s, f, cleanup))
        signal.signal(signal.SIGTERM, lambda s, f: signal_handler(s, f, cleanup))
        
        # Cleanup bei normalem Exit
        if cleanup_certs:
            atexit.register(lambda: cleanup_files(temp_cert, temp_key))
        
        # Server-Info anzeigen
        local_ip = get_local_ip()
        
        log_success(f"{protocol}-Server gestartet!")
        print(f"{Colors.MAGENTA}==========================================={Colors.NC}")
        print(f"{Colors.GREEN}üìÅ Verzeichnis:{Colors.NC} {os.path.abspath(directory)}")
        print(f"{Colors.GREEN}üåê Zugriff:{Colors.NC}")
        print(f"   Lokal:    {protocol.lower()}://localhost:{port}/")
        if interface == "0.0.0.0":
            print(f"   Netzwerk: {protocol.lower()}://{local_ip}:{port}/")
        print(f"{Colors.GREEN}üîë Protokoll:{Colors.NC} {protocol}")
        if use_ssl and cert_file is None:
            print(f"{Colors.YELLOW}‚ö†Ô∏è  Selbstsigniertes Zertifikat - Browser-Warnung erwartet{Colors.NC}")
        print(f"{Colors.MAGENTA}==========================================={Colors.NC}")
        print(f"{Colors.BLUE}Zum Beenden: Ctrl+C{Colors.NC}")
        print()
        
        # Server starten
        httpd.serve_forever()
        
    except OSError as e:
        if e.errno == 48:  # Address already in use
            log_error(f"Port {port} bereits in Verwendung")
        elif e.errno == 13:  # Permission denied
            log_error(f"Keine Berechtigung f√ºr Port {port} (verwende Port > 1024)")
        else:
            log_error(f"Server-Fehler: {e}")
        return False
    except KeyboardInterrupt:
        log_info("Server gestoppt")
        return True
    finally:
        if cleanup_certs:
            cleanup_files(temp_cert, temp_key)

def main():
    parser = argparse.ArgumentParser(
        description="Schneller HTTPS/HTTP-Server f√ºr lokale Entwicklung",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Beispiele:
  %(prog)s                                    # HTTPS-Server auf Port 8443
  %(prog)s --http                             # HTTP-Server auf Port 8000
  %(prog)s -p 9000                            # HTTPS-Server auf Port 9000
  %(prog)s -d /path/to/files                  # Bestimmtes Verzeichnis servieren
  %(prog)s --cert cert.pem --key key.pem     # Eigene SSL-Zertifikate
  %(prog)s --interface 127.0.0.1             # Nur lokal erreichbar
  %(prog)s --subject "/CN=myhost.local"       # Custom SSL-Subject
        """
    )
    
    # Grundlegende Optionen
    parser.add_argument('-d', '--directory', 
                       default=os.getcwd(),
                       help='Zu servierendes Verzeichnis (Standard: aktuelles Verzeichnis)')
    
    parser.add_argument('-p', '--port', 
                       type=int, 
                       help='Port (Standard: 8443 f√ºr HTTPS, 8000 f√ºr HTTP)')
    
    parser.add_argument('-i', '--interface', 
                       default='0.0.0.0',
                       help='Interface/IP-Adresse (Standard: 0.0.0.0 f√ºr alle Interfaces)')
    
    # SSL/HTTPS Optionen
    parser.add_argument('--http', 
                       action='store_true',
                       help='HTTP statt HTTPS verwenden')
    
    parser.add_argument('--cert', 
                       help='Pfad zur SSL-Zertifikatsdatei (.pem)')
    
    parser.add_argument('--key', 
                       help='Pfad zur SSL-Key-Datei (.pem)')
    
    parser.add_argument('--subject', 
                       help='SSL-Zertifikat Subject (Standard: /C=DE/ST=DEV/L=Local/O=DevServer/CN=localhost)')
    
    parser.add_argument('--keep-certs', 
                       action='store_true',
                       help='Tempor√§re SSL-Zertifikate nicht l√∂schen')
    
    # Sonstige Optionen
    parser.add_argument('-v', '--verbose', 
                       action='store_true',
                       help='Detaillierte Ausgabe')
    
    args = parser.parse_args()
    
    # Port-Standard setzen
    if args.port is None:
        args.port = 8000 if args.http else 8443
    
    # SSL-Konfiguration validieren
    use_ssl = not args.http
    
    if args.cert and not args.key:
        log_error("--cert erfordert auch --key")
        return 1
    
    if args.key and not args.cert:
        log_error("--key erfordert auch --cert")
        return 1
    
    # Port validieren
    if not (1 <= args.port <= 65535):
        log_error(f"Ung√ºltiger Port: {args.port}")
        return 1
    
    # Abh√§ngigkeiten pr√ºfen (nur bei SSL)
    if use_ssl and not args.cert:
        if not check_dependencies():
            return 1
    
    # Server starten
    try:
        success = serve_directory(
            directory=args.directory,
            port=args.port,
            interface=args.interface,
            use_ssl=use_ssl,
            cert_file=args.cert,
            key_file=args.key,
            subject=args.subject,
            cleanup_certs=not args.keep_certs,
            verbose=args.verbose
        )
        return 0 if success else 1
        
    except Exception as e:
        log_error(f"Unerwarteter Fehler: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1

if __name__ == '__main__':
    sys.exit(main())