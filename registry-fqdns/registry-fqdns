#!/usr/bin/env bash

# Script: crane-fqdn
# Zweck: Extrahiert FQDNs für Container-Registry Firewall-Freischaltungen
# Verwendung: ./crane-fqdn [OPTIONS] <image>

set -euo pipefail

# Farben für Output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'  # No Color

# Funktionen für farbigen Output
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1" >&2
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

log_verbose() {
    if [[ "${VERBOSE:-false}" == "true" ]]; then
        echo -e "${BLUE}[VERBOSE]${NC} $1" >&2
    fi
}

# Hilfe anzeigen
show_help() {
    cat << EOF
Crane FQDN Extractor - Container-Registry FQDN Extraktion für Firewall-Regeln

VERWENDUNG:
    $0 [OPTIONEN] <image>

BESCHREIBUNG:
    Extrahiert alle FQDNs (Fully Qualified Domain Names) aus der crane-Verbose-
    Ausgabe beim Pull eines Container-Images. Nützlich für die Erstellung von
    Firewall-Regeln und Registry-Allowlists.

OPTIONEN:
    -c, --comma         Nur komma-getrennte Liste ausgeben (für Automatisierung)
    -v, --verbose       Detaillierte Ausgabe
    -h, --help          Diese Hilfe anzeigen

ARGUMENTE:
    image               Container-Image (z.B. nginx:latest, gcr.io/project/image:tag)

BEISPIELE:
    # Vollständige Ausgabe
    $0 nginx:latest

    # Nur komma-getrennte Liste
    $0 --comma registry.rancher.com/rancher/rancher:v2.10.3

    # Mit detaillierter Ausgabe
    $0 -v gcr.io/project/image:tag

FUNKTIONSWEISE:
    Das Script analysiert die verbose crane-Ausgabe und extrahiert FQDNs:
    crane -v pull <image> /tmp/image.tgz 2>&1 | grep "\\-\\->\\|<\\-\\-" | ...

VORAUSSETZUNGEN:
    - crane: go install github.com/google/go-containerregistry/cmd/crane@latest

EXIT-CODES:
    0 - Erfolg, FQDNs gefunden
    1 - Fehler (fehlende Abhängigkeiten, keine FQDNs gefunden)

EOF
}

# Abhängigkeiten prüfen
check_dependencies() {
    local missing_deps=()

    if ! command -v crane &> /dev/null; then
        missing_deps+=("crane")
    fi

    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_error "Fehlende Abhängigkeiten: ${missing_deps[*]}"
        log_info "Installation:"
        for dep in "${missing_deps[@]}"; do
            case "$dep" in
                crane)
                    log_info "  crane: go install github.com/google/go-containerregistry/cmd/crane@latest"
                    ;;
            esac
        done
        return 1
    fi

    log_verbose "Alle Abhängigkeiten gefunden"
    return 0
}

# Parameter parsen
parse_arguments() {
    COMMA_ONLY=false
    VERBOSE=false
    IMAGE=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            -c|--comma)
                COMMA_ONLY=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            -*)
                log_error "Unbekannte Option: $1"
                echo "Verwende --help für Hilfe." >&2
                exit 1
                ;;
            *)
                IMAGE="$1"
                shift
                ;;
        esac
    done

    # Validierung
    if [[ -z "$IMAGE" ]]; then
        log_error "Kein Image angegeben!"
        echo "Verwende --help für Hilfe." >&2
        exit 1
    fi

    log_verbose "Image: $IMAGE"
    log_verbose "Comma-Only: $COMMA_ONLY"
}

# FQDNs extrahieren
extract_fqdns() {
    local image="$1"
    local temp_file

    # Temporäre Datei für das Image (mit PID für Eindeutigkeit)
    temp_file=$(mktemp /tmp/crane_image_$$_XXXXXX.tgz)

    # Cleanup bei Exit
    trap "rm -f '$temp_file'" EXIT

    log_verbose "Temporäre Datei: $temp_file"

    if [[ "$COMMA_ONLY" == "false" ]]; then
        log_info "Extrahiere FQDNs für Image: $image"
    fi

    log_verbose "Führe crane -v pull aus..."

    # FQDN-Extraktion mit dem funktionierenden Oneliner-Pattern
    local fqdns
    fqdns=$(crane -v pull "$image" "$temp_file" 2>&1 | \
        grep "\-\->\|<\-\-" | \
        grep -o -E 'https?://[^,]+' | \
        tr ',' '\n' | \
        cut -d'/' -f1-3 | \
        sed -E 's|^https?://||' | \
        sort -u)

    log_verbose "FQDN-Extraktion abgeschlossen"

    echo "$fqdns"
}

# Ergebnisse anzeigen
show_results() {
    local fqdns="$1"

    if [[ -z "$fqdns" ]]; then
        if [[ "$COMMA_ONLY" == "false" ]]; then
            log_error "Keine FQDNs gefunden!"
        fi
        return 1
    fi

    if [[ "$COMMA_ONLY" == "true" ]]; then
        # Nur komma-getrennte Liste ausgeben
        echo "$fqdns" | tr '\n' ',' | sed 's/,$//'
    else
        # Vollständige Ausgabe
        echo
        log_success "Gefundene FQDNs:"
        echo "==========================" >&2
        echo "$fqdns"
        echo "==========================" >&2

        local fqdn_count
        fqdn_count=$(echo "$fqdns" | wc -l | tr -d ' ')
        log_info "Insgesamt $fqdn_count unique FQDNs gefunden"

        echo >&2
        log_info "Für Firewall-Regel (komma-getrennt):"
        echo "$fqdns" | tr '\n' ',' | sed 's/,$//'
        echo >&2
    fi

    return 0
}

# Hauptfunktion
main() {
    # 1. Parameter parsen
    parse_arguments "$@"

    # 2. Abhängigkeiten prüfen
    if ! check_dependencies; then
        exit 2
    fi

    # 3. FQDNs extrahieren
    local fqdns
    fqdns=$(extract_fqdns "$IMAGE")

    # 4. Ergebnisse anzeigen
    if ! show_results "$fqdns"; then
        exit 1
    fi
}

# Script ausführen
main "$@"
