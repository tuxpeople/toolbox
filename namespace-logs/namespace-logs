#!/usr/bin/env bash

# namespace-logs - Kubernetes Namespace Log Exporter
# Exportiert alle Container-Logs eines Kubernetes-Namespaces in einem Zeitraum

set -euo pipefail

# Globale Variablen
NAMESPACE=""
START_TIME=""
END_TIME=""
OUTPUT_DIR=""
VERBOSE=false
DRY_RUN=false
FORCE=false

# Farb-Definitionen für Logs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Log-Funktionen
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1" >&2
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

log_verbose() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo -e "${BLUE}[VERBOSE]${NC} $1" >&2
    fi
}

# Hilfe-Funktion
show_help() {
    cat << EOF
namespace-logs - Kubernetes Namespace Log Exporter

VERWENDUNG:
    namespace-logs -n NAMESPACE -s START_TIME -e END_TIME -o OUTPUT_DIR [OPTIONEN]

OPTIONEN:
    -n, --namespace NAMESPACE    Kubernetes-Namespace (erforderlich)
    -s, --start-time TIME        Start-Zeit (ISO 8601 Format, z.B. 2025-08-25T13:00:00Z)
    -e, --end-time TIME          End-Zeit (ISO 8601 Format, z.B. 2025-08-25T14:00:00Z)
    -o, --output-dir DIR         Output-Verzeichnis für Log-Dateien
    -v, --verbose                Detaillierte Ausgabe
    -n, --dry-run                Nur anzeigen was gemacht würde
    -f, --force                  Überschreibe existierenden Output-Ordner ohne Nachfrage
    -h, --help                   Diese Hilfe anzeigen

BEISPIELE:
    # Logs zwischen 13:00 und 14:00 exportieren
    namespace-logs -n production -s "2025-08-25T13:00:00Z" -e "2025-08-25T14:00:00Z" -o ./logs

    # Dry-Run um zu sehen was exportiert würde
    namespace-logs -n staging -s "2025-08-25T13:00:00Z" -e "2025-08-25T14:00:00Z" -o ./logs --dry-run

    # Mit Force-Modus (überschreibt existierende Dateien)
    namespace-logs -n production -s "2025-08-25T13:00:00Z" -e "2025-08-25T14:00:00Z" -o ./logs --force

HINWEISE:
    - kubectl muss installiert und konfiguriert sein
    - Zeitformat muss ISO 8601 sein (YYYY-MM-DDTHH:MM:SSZ)
    - Bei --start-time ohne --end-time wird bis jetzt exportiert
    - Output-Dateien: {pod_name}_{container_name}.log
EOF
}

# Abhängigkeiten prüfen
check_dependencies() {
    local missing_deps=()
    
    if ! command -v kubectl &> /dev/null; then
        missing_deps+=("kubectl")
    fi
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_error "Fehlende Abhängigkeiten: ${missing_deps[*]}"
        log_error "Bitte installiere alle erforderlichen Tools"
        return 1
    fi
    
    # kubectl Cluster-Verbindung prüfen
    if ! kubectl cluster-info &> /dev/null; then
        log_error "Keine Verbindung zum Kubernetes-Cluster möglich"
        log_error "Prüfe deine kubectl-Konfiguration"
        return 1
    fi
    
    return 0
}

# Validate ISO 8601 timestamp
validate_timestamp() {
    local timestamp="$1"
    local field_name="$2"
    
    # Basic ISO 8601 format check
    if [[ ! "$timestamp" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z$ ]]; then
        log_error "${field_name} muss im ISO 8601 Format sein (YYYY-MM-DDTHH:MM:SSZ)"
        return 1
    fi
    
    return 0
}

# Namespace validieren
validate_namespace() {
    local namespace="$1"
    
    if ! kubectl get namespace "$namespace" &> /dev/null; then
        log_error "Namespace '$namespace' existiert nicht"
        return 1
    fi
    
    return 0
}

# Parameter parsen
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -n|--namespace)
                NAMESPACE="$2"
                shift 2
                ;;
            -s|--start-time)
                START_TIME="$2"
                shift 2
                ;;
            -e|--end-time)
                END_TIME="$2"
                shift 2
                ;;
            -o|--output-dir)
                OUTPUT_DIR="$2"
                shift 2
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            -f|--force)
                FORCE=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log_error "Unbekannte Option: $1"
                show_help
                exit 1
                ;;
        esac
    done
}

# Parameter validieren
validate_parameters() {
    if [[ -z "$NAMESPACE" ]]; then
        log_error "Namespace ist erforderlich (-n/--namespace)"
        return 1
    fi
    
    if [[ -z "$START_TIME" ]]; then
        log_error "Start-Zeit ist erforderlich (-s/--start-time)"
        return 1
    fi
    
    if [[ -z "$OUTPUT_DIR" ]]; then
        log_error "Output-Verzeichnis ist erforderlich (-o/--output-dir)"
        return 1
    fi
    
    # Zeitstempel validieren
    if ! validate_timestamp "$START_TIME" "Start-Zeit"; then
        return 1
    fi
    
    if [[ -n "$END_TIME" ]]; then
        if ! validate_timestamp "$END_TIME" "End-Zeit"; then
            return 1
        fi
    fi
    
    # Namespace validieren
    if ! validate_namespace "$NAMESPACE"; then
        return 1
    fi
    
    return 0
}

# Bestätigung für existierenden Output-Ordner
confirm_overwrite() {
    if [[ "$FORCE" == "true" ]]; then
        return 0
    fi
    
    if [[ -d "$OUTPUT_DIR" ]]; then
        log_warn "Output-Verzeichnis '$OUTPUT_DIR' existiert bereits"
        read -p "Möchtest du den Inhalt überschreiben? [y/N]: " -r
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log_info "Abgebrochen"
            exit 0
        fi
    fi
}

# Logs exportieren
export_logs() {
    local namespace="$1"
    local start_time="$2"
    local end_time="$3"
    local output_dir="$4"
    
    log_info "Exportiere Logs aus Namespace: $namespace"
    log_verbose "Start-Zeit: $start_time"
    if [[ -n "$end_time" ]]; then
        log_verbose "End-Zeit: $end_time"
    fi
    log_verbose "Output-Verzeichnis: $output_dir"
    
    if [[ "$DRY_RUN" == "false" ]]; then
        mkdir -p "$output_dir"
    fi
    
    # Alle Pods im Namespace auflisten
    local pods
    if ! pods=$(kubectl get pods -n "$namespace" -o jsonpath='{.items[*].metadata.name}' 2>/dev/null); then
        log_error "Fehler beim Auflisten der Pods in Namespace '$namespace'"
        return 1
    fi
    
    if [[ -z "$pods" ]]; then
        log_warn "Keine Pods in Namespace '$namespace' gefunden"
        return 0
    fi
    
    local pod_count
    pod_count=$(echo "$pods" | wc -w | tr -d ' ')
    log_info "Gefundene Pods: $pod_count"
    
    local exported_logs=0
    local failed_exports=0
    
    for pod in $pods; do
        log_verbose "Verarbeite Pod: $pod"
        
        # Alle Container im Pod auflisten
        local containers
        if ! containers=$(kubectl get pod "$pod" -n "$namespace" -o jsonpath='{.spec.containers[*].name}' 2>/dev/null); then
            log_warn "Fehler beim Auflisten der Container für Pod '$pod'"
            ((failed_exports++))
            continue
        fi
        
        if [[ -z "$containers" ]]; then
            log_warn "Keine Container in Pod '$pod' gefunden"
            continue
        fi
        
        for container in $containers; do
            local log_file="${output_dir}/${pod}_${container}.log"
            
            if [[ "$DRY_RUN" == "true" ]]; then
                echo "Würde exportieren: Pod=$pod, Container=$container -> $log_file"
                ((exported_logs++))
                continue
            fi
            
            log_verbose "Exportiere Logs für Pod: $pod, Container: $container"
            
            # kubectl logs Kommando bauen
            local kubectl_cmd="kubectl logs $pod -c $container -n $namespace --since-time=$start_time"
            if [[ -n "$end_time" ]]; then
                kubectl_cmd="$kubectl_cmd --until-time=$end_time"
            fi
            
            # Logs exportieren
            if eval "$kubectl_cmd" > "$log_file" 2>/dev/null; then
                local log_size
                log_size=$(wc -l < "$log_file" | tr -d ' ')
                log_verbose "Erfolgreich exportiert: $log_file ($log_size Zeilen)"
                ((exported_logs++))
            else
                log_warn "Fehler beim Exportieren der Logs für Pod '$pod', Container '$container'"
                rm -f "$log_file" 2>/dev/null || true
                ((failed_exports++))
            fi
        done
    done
    
    log_success "Export abgeschlossen"
    log_info "Erfolgreich exportierte Logs: $exported_logs"
    if [[ $failed_exports -gt 0 ]]; then
        log_warn "Fehlgeschlagene Exports: $failed_exports"
    fi
}

# Hauptfunktion
main() {
    log_info "namespace-logs - Kubernetes Namespace Log Exporter"
    
    # Parameter parsen
    parse_arguments "$@"
    
    # Parameter validieren
    if ! validate_parameters; then
        exit 1
    fi
    
    # Abhängigkeiten prüfen
    if ! check_dependencies; then
        exit 1
    fi
    
    # Bestätigung für Überschreibung
    if [[ "$DRY_RUN" == "false" ]]; then
        confirm_overwrite
    fi
    
    # Logs exportieren
    if ! export_logs "$NAMESPACE" "$START_TIME" "$END_TIME" "$OUTPUT_DIR"; then
        exit 1
    fi
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "Dry-Run abgeschlossen - keine Dateien erstellt"
    else
        log_success "Alle Logs exportiert nach: $OUTPUT_DIR"
    fi
}

# Script ausführen wenn direkt aufgerufen
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi