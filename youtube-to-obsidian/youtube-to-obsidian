#!/usr/bin/env python3
"""
YouTube zu Obsidian Konverter

Erstellt strukturierte Zusammenfassungen von YouTube-Videos f√ºr Obsidian
mit Claude CLI.
"""

import sys
import json
import subprocess
import argparse
from datetime import datetime
from pathlib import Path


def log_info(message):
    """Gibt eine Info-Nachricht aus"""
    print(f"[INFO] {message}", file=sys.stderr)


def log_success(message):
    """Gibt eine Erfolgs-Nachricht aus"""
    print(f"[SUCCESS] {message}", file=sys.stderr)


def log_error(message):
    """Gibt eine Fehler-Nachricht aus"""
    print(f"[ERROR] {message}", file=sys.stderr)


def log_verbose(message, verbose=False):
    """Gibt eine Verbose-Nachricht aus, falls Verbose-Modus aktiv ist"""
    if verbose:
        print(f"[VERBOSE] {message}", file=sys.stderr)


def check_dependencies(verbose=False):
    """
    Pr√ºft ob alle erforderlichen Tools installiert sind

    Args:
        verbose: Falls True, gibt detaillierte Informationen aus

    Returns:
        True falls alle Abh√§ngigkeiten vorhanden sind, sonst False
    """
    missing_deps = []

    # Pr√ºfe yt-dlp
    try:
        result = subprocess.run(['yt-dlp', '--version'],
                              capture_output=True,
                              check=True,
                              timeout=5)
        log_verbose(f"yt-dlp Version: {result.stdout.decode().strip()}", verbose)
    except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
        missing_deps.append("yt-dlp")

    # Pr√ºfe claude CLI
    try:
        result = subprocess.run(['claude', '-v'],
                              capture_output=True,
                              check=True,
                              timeout=5)
        log_verbose(f"Claude Version: {result.stdout.decode().strip()}", verbose)
    except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
        missing_deps.append("claude")

    if missing_deps:
        log_error(f"Fehlende Abh√§ngigkeiten: {', '.join(missing_deps)}")
        log_info("Installation:")
        if "yt-dlp" in missing_deps:
            log_info("  yt-dlp: brew install yt-dlp")
        if "claude" in missing_deps:
            log_info("  claude: brew install claude-code")
        return False

    return True


def get_video_info(url, verbose=False):
    """
    Holt Video-Metadaten mit yt-dlp

    Args:
        url: YouTube-Video URL
        verbose: Falls True, gibt detaillierte Informationen aus

    Returns:
        Dictionary mit Video-Metadaten

    Raises:
        SystemExit: Bei Fehlern w√§hrend des Abrufens
    """
    log_info(f"Hole Video-Informationen von: {url}")
    log_verbose("F√ºhre yt-dlp aus...", verbose)

    try:
        result = subprocess.run(
            ['yt-dlp', '--skip-download', '--print-json', '--no-warnings', url],
            capture_output=True,
            text=True,
            check=True,
            timeout=30
        )

        video_data = json.loads(result.stdout)
        log_verbose(f"Video-Daten geladen: {len(result.stdout)} bytes", verbose)
        return video_data

    except subprocess.CalledProcessError as e:
        log_error(f"Fehler beim Abrufen der Video-Daten: {e}")
        if e.stderr:
            log_error(f"Details: {e.stderr}")
        sys.exit(1)
    except subprocess.TimeoutExpired:
        log_error("Timeout beim Abrufen der Video-Daten (30s)")
        sys.exit(1)
    except json.JSONDecodeError as e:
        log_error(f"Fehler beim Parsen der JSON-Antwort: {e}")
        sys.exit(1)
    except Exception as e:
        log_error(f"Unerwarteter Fehler: {e}")
        sys.exit(1)


def create_summary_with_claude(video_data, verbose=False):
    """
    Erstellt Zusammenfassung mit Claude CLI - OHNE Transkript

    Args:
        video_data: Dictionary mit Video-Metadaten von yt-dlp
        verbose: Falls True, gibt detaillierte Informationen aus

    Returns:
        String mit der generierten Zusammenfassung

    Raises:
        SystemExit: Bei Fehlern w√§hrend der Claude-Kommunikation
    """
    log_info("Erstelle Zusammenfassung mit Claude CLI...")

    # Video-Metadaten extrahieren
    title = video_data.get('title', 'Unbekanntes Video')
    channel = video_data.get('channel', 'Unbekannter Kanal')
    duration = video_data.get('duration', 0)
    duration_min = duration // 60
    video_url = video_data.get('webpage_url', '')
    video_id = video_data.get('id', '')
    description = video_data.get('description', '')

    log_verbose(f"Video: {title}", verbose)
    log_verbose(f"Kanal: {channel}", verbose)
    log_verbose(f"Dauer: {duration_min} Minuten", verbose)

    # Prompt f√ºr Claude zusammenstellen
    prompt = f"""Analysiere dieses YouTube-Video und erstelle eine strukturierte Zusammenfassung f√ºr Obsidian.

Video: {title}
Kanal: {channel}
Dauer: {duration_min} Minuten
URL: {video_url}
Video-ID: {video_id}

Beschreibung:
{description[:2000] if description else 'Keine Beschreibung verf√ºgbar'}

HINWEIS: Kein Transkript verf√ºgbar. Erstelle die Zusammenfassung basierend auf Titel und Beschreibung.

Erstelle eine Markdown-Zusammenfassung mit diesen Abschnitten (OHNE zus√§tzliche Titel am Anfang):

1. **Executive Summary (TL;DR)** - 2-3 S√§tze, worum geht es?
2. **Hauptthemen** - Die wichtigsten Konzepte (basierend auf Titel/Beschreibung)
3. **Praktische Relevanz** - Warum ist das f√ºr einen Kubernetes/DevOps Engineer interessant?
4. **Gesch√§tzte Abschnitte** - Sch√§tze sinnvolle Zeitabschnitte basierend auf der Videol√§nge
   Format: [ca. 0:00-5:00](https://youtu.be/{video_id}?t=0) - Einf√ºhrung
   [ca. 5:00-15:00](https://youtu.be/{video_id}?t=300) - Hauptteil
   etc.
5. **Was du lernen k√∂nntest** - Erwartete Inhalte
6. **N√§chste Schritte** - Konkrete Action Items als Checkliste

Nutze Emojis f√ºr bessere √úbersicht. Schreibe auf Deutsch (Schweizer Rechtschreibung: ss statt √ü).
Fokussiere auf IT/DevOps/Kubernetes-Relevanz.

WICHTIG:
- Gib NUR die Zusammenfassung zur√ºck, KEINE zus√§tzlichen Titel oder Header am Anfang
- Beginne direkt mit "## üìã Executive Summary (TL;DR)"
- KEIN "# Video-Titel" am Anfang - das kommt schon automatisch
"""

    try:
        log_verbose("Sende Prompt an Claude CLI...", verbose)
        result = subprocess.run(
            ['claude'],
            input=prompt,
            capture_output=True,
            text=True,
            check=True,
            timeout=120
        )

        log_verbose(f"Claude-Antwort: {len(result.stdout)} Zeichen", verbose)
        return result.stdout.strip()

    except subprocess.CalledProcessError as e:
        log_error(f"Fehler bei Claude CLI: {e}")
        if e.stderr:
            log_error(f"Details: {e.stderr}")
        sys.exit(1)
    except subprocess.TimeoutExpired:
        log_error("Timeout: Claude brauchte zu lange (120s)")
        sys.exit(1)
    except Exception as e:
        log_error(f"Unerwarteter Fehler: {e}")
        sys.exit(1)


def create_obsidian_note(video_data, summary, output_path=None, verbose=False):
    """
    Erstellt Obsidian-Note mit Frontmatter

    Args:
        video_data: Dictionary mit Video-Metadaten
        summary: String mit der generierten Zusammenfassung
        output_path: Optionaler Pfad zur Ausgabedatei (None = stdout)
        verbose: Falls True, gibt detaillierte Informationen aus

    Returns:
        String mit der vollst√§ndigen Note
    """
    title = video_data.get('title', 'Unbekanntes Video')
    channel = video_data.get('channel', 'Unbekannter Kanal')
    video_url = video_data.get('webpage_url', '')
    video_id = video_data.get('id', '')
    duration = video_data.get('duration', 0)
    duration_min = duration // 60

    # Frontmatter erstellen
    frontmatter = f"""---
aliases: []
tags:
  - Video
  - Tutorial
language: de
title: {title}
date: {datetime.now().strftime('%Y-%m-%d')}
source: {video_url}
author: {channel}
video_id: {video_id}
---

"""

    # Titel und Metadaten mit klickbarem Link
    header = f"""# {title}

**Kanal:** {channel} | **Dauer:** {duration_min} Min | **Video:** [YouTube]({video_url})

---

"""

    # Vollst√§ndige Note zusammenbauen
    full_note = frontmatter + header + summary

    # Speichern
    if output_path is None:
        # Standard: Ausgabe auf stdout
        print(full_note)
    else:
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)
        output_file.write_text(full_note, encoding='utf-8')
        log_success(f"Zusammenfassung gespeichert: {output_file}")

    log_verbose(f"Note erstellt: {len(full_note)} Zeichen", verbose)
    return full_note


def main():
    """Hauptfunktion - Koordiniert den gesamten Ablauf"""
    parser = argparse.ArgumentParser(
        description='YouTube zu Obsidian Konverter - Erstellt strukturierte Zusammenfassungen',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Beispiele:
  # Ausgabe auf Terminal
  %(prog)s https://www.youtube.com/watch?v=klyAhaklGNU

  # In Datei speichern
  %(prog)s https://www.youtube.com/watch?v=klyAhaklGNU output.md

  # In Obsidian Vault speichern
  %(prog)s https://www.youtube.com/watch?v=klyAhaklGNU ~/vault/notes/video.md

  # Mit detaillierter Ausgabe
  %(prog)s https://www.youtube.com/watch?v=klyAhaklGNU --verbose

Hinweis:
  F√ºr detailliertere Zusammenfassungen kopiere das Transkript manuell von YouTube
  und f√ºge es der generierten Notiz hinzu.

Voraussetzungen:
  - yt-dlp: brew install yt-dlp
  - claude: brew install claude-code
        """
    )

    parser.add_argument(
        'url',
        help='YouTube-Video URL'
    )

    parser.add_argument(
        'output',
        nargs='?',
        default=None,
        help='Ausgabedatei (optional, Standard: stdout)'
    )

    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Detaillierte Ausgabe'
    )

    args = parser.parse_args()

    log_info("YouTube zu Obsidian Konverter")
    log_verbose("Verbose-Modus aktiviert", args.verbose)

    # 1. Abh√§ngigkeiten pr√ºfen
    if not check_dependencies(args.verbose):
        sys.exit(2)

    log_verbose("Alle Abh√§ngigkeiten gefunden", args.verbose)

    # 2. Video-Infos holen
    video_data = get_video_info(args.url, args.verbose)
    log_success(f"Video: {video_data.get('title', 'Unbekannt')}")
    log_info(f"Kanal: {video_data.get('channel', 'Unbekannt')}")
    log_info(f"Dauer: {video_data.get('duration', 0) // 60} Minuten")

    # 3. Claude-Zusammenfassung erstellen (ohne Transkript)
    log_info("Erstelle Zusammenfassung basierend auf Titel und Beschreibung")
    summary = create_summary_with_claude(video_data, args.verbose)
    log_success("Zusammenfassung erstellt")

    # 4. Obsidian-Note erstellen
    create_obsidian_note(video_data, summary, args.output, args.verbose)

    if args.output:
        log_success("Fertig!")
    else:
        log_info("Ausgabe auf stdout", file=sys.stderr)

    # Hinweis f√ºr detailliertere Zusammenfassungen
    log_info("", file=sys.stderr)
    log_info("üí° Hinweis: F√ºr detailliertere Zusammenfassungen:", file=sys.stderr)
    log_info("   1. √ñffne das Video auf YouTube", file=sys.stderr)
    log_info("   2. Klick auf '...' ‚Üí 'Transkript anzeigen'", file=sys.stderr)
    log_info("   3. Kopiere den Text und f√ºge ihn der Notiz hinzu", file=sys.stderr)


if __name__ == "__main__":
    main()
