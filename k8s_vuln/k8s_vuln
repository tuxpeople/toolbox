#!/usr/bin/env bash

# Script: k8s_vuln.sh
# Zweck: Scannt Kubernetes-Cluster auf Sicherheitslücken in Container-Images
# Verwendung: ./k8s_vuln.sh <cve-id> [options]

set -euo pipefail

# Farben für Output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
NC='\033[0m'

# Funktionen für farbigen Output
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_vuln() {
    echo -e "${RED}[VULNERABLE]${NC} $1"
}

log_safe() {
    echo -e "${GREEN}[SAFE]${NC} $1"
}

# Hilfe anzeigen
show_help() {
    cat << EOF
Kubernetes Vulnerability Scanner

VERWENDUNG:
    $0 <cve-id|vulnerability> [options]

BESCHREIBUNG:
    Scannt alle Container-Images in einem Kubernetes-Cluster auf spezifische
    Sicherheitslücken mit Trivy. Unterstützt verschiedene Namespaces und 
    Severity-Level.

OPTIONEN:
    -n, --namespace NAMESPACE    Nur bestimmten Namespace scannen
    -s, --severity SEVERITY      Minimum Severity (LOW,MEDIUM,HIGH,CRITICAL)
    -o, --output FORMAT          Ausgabeformat (table,json,sarif)
    -v, --verbose               Detaillierte Ausgabe
    -q, --quiet                 Nur vulnerable Images anzeigen
    --no-progress               Fortschrittsbalken deaktivieren
    --timeout SECONDS           Timeout pro Image (Standard: 300)
    -h, --help                  Diese Hilfe anzeigen

BEISPIELE:
    $0 CVE-2021-44228                           # Log4j Vulnerability
    $0 CVE-2022-0492                            # Container Escape
    $0 log4j -s HIGH                            # Log4j mit HIGH+ Severity
    $0 CVE-2021-44228 -n kube-system            # Nur kube-system Namespace
    $0 CVE-2021-44228 -o json > results.json    # JSON Output in Datei
    $0 CVE-2021-44228 --quiet                   # Nur vulnerable Images

VORAUSSETZUNGEN:
    - trivy muss installiert sein
    - kubectl muss konfiguriert und verfügbar sein
    - Zugriff auf Kubernetes-Cluster

EOF
}

# Abhängigkeiten prüfen
check_dependencies() {
    local missing_deps=()
    
    if ! command -v trivy &> /dev/null; then
        missing_deps+=("trivy")
    fi
    
    if ! command -v kubectl &> /dev/null; then
        missing_deps+=("kubectl")
    fi
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_error "Fehlende Abhängigkeiten: ${missing_deps[*]}"
        log_info "Installation:"
        log_info "  trivy: https://aquasecurity.github.io/trivy/latest/getting-started/installation/"
        log_info "  kubectl: https://kubernetes.io/docs/tasks/tools/"
        exit 1
    fi
}

# Kubernetes-Zugriff prüfen
check_k8s_access() {
    log_info "Prüfe Kubernetes-Zugriff..."
    
    if ! kubectl version --client &>/dev/null; then
        log_error "kubectl ist nicht korrekt konfiguriert"
        exit 1
    fi
    
    if ! kubectl cluster-info &>/dev/null; then
        log_error "Keine Verbindung zum Kubernetes-Cluster"
        log_info "Prüfe kubectl-Konfiguration: kubectl config view"
        exit 1
    fi
    
    local cluster_name
    cluster_name=$(kubectl config current-context 2>/dev/null || echo "unknown")
    log_info "Verbunden mit Cluster: $cluster_name"
}

# Container-Images aus Cluster extrahieren
get_container_images() {
    local namespace="$1"
    local verbose="$2"
    
    log_info "Extrahiere Container-Images aus Cluster..."
    
    local kubectl_cmd="kubectl get pods"
    if [[ "$namespace" != "all" ]]; then
        kubectl_cmd="$kubectl_cmd -n $namespace"
    else
        kubectl_cmd="$kubectl_cmd -A"
    fi
    
    local jsonpath='{range .items[*]}{range .spec.containers[*]}{.image}{"\n"}{end}{range .spec.initContainers[*]}{.image}{"\n"}{end}{end}'
    kubectl_cmd="$kubectl_cmd -o jsonpath='$jsonpath'"
    
    if [[ "$verbose" == "true" ]]; then
        log_info "Ausgeführter Befehl: $kubectl_cmd"
    fi
    
    local images
    if images=$(eval "$kubectl_cmd" 2>/dev/null); then
        # Images normalisieren und deduplizieren
        echo "$images" | grep -v "^$" | sort -u
    else
        log_error "Fehler beim Extrahieren der Container-Images"
        exit 1
    fi
}

# Image mit Trivy scannen
scan_image() {
    local image="$1"
    local vulnerability="$2"
    local severity="$3"
    local output_format="$4"
    local verbose="$5"
    local timeout="$6"
    local no_progress="$7"
    
    local trivy_cmd="trivy image"
    
    # Severity-Filter
    if [[ -n "$severity" ]]; then
        trivy_cmd="$trivy_cmd --severity $severity"
    fi
    
    # Output-Format
    if [[ "$output_format" != "table" ]]; then
        trivy_cmd="$trivy_cmd --format $output_format"
    fi
    
    # Progress-Bar
    if [[ "$no_progress" == "true" ]]; then
        trivy_cmd="$trivy_cmd --no-progress"
    fi
    
    # Timeout
    trivy_cmd="$trivy_cmd --timeout ${timeout}s"
    
    # Quiet Mode für interne Prüfung
    trivy_cmd="$trivy_cmd --quiet"
    
    # Image hinzufügen
    trivy_cmd="$trivy_cmd $image"
    
    if [[ "$verbose" == "true" ]]; then
        log_info "Scanning: $trivy_cmd"
    fi
    
    # Scan ausführen und Ergebnis zurückgeben
    local scan_result
    if scan_result=$(timeout "${timeout}" $trivy_cmd 2>/dev/null); then
        echo "$scan_result"
        return 0
    else
        return 1
    fi
}

# Prüfen ob Image vulnerable ist
is_vulnerable() {
    local scan_result="$1"
    local vulnerability="$2"
    
    # Case-insensitive Suche nach Vulnerability
    if echo "$scan_result" | grep -qi "$vulnerability"; then
        return 0
    else
        return 1
    fi
}

# Detailliertes Scan-Ergebnis anzeigen
show_detailed_scan() {
    local image="$1"
    local vulnerability="$2"
    local severity="$3"
    local output_format="$4"
    local timeout="$5"
    local no_progress="$6"
    
    local trivy_cmd="trivy image"
    
    # Severity-Filter
    if [[ -n "$severity" ]]; then
        trivy_cmd="$trivy_cmd --severity $severity"
    fi
    
    # Output-Format
    if [[ "$output_format" != "table" ]]; then
        trivy_cmd="$trivy_cmd --format $output_format"
    fi
    
    # Progress-Bar
    if [[ "$no_progress" == "true" ]]; then
        trivy_cmd="$trivy_cmd --no-progress"
    fi
    
    # Timeout
    trivy_cmd="$trivy_cmd --timeout ${timeout}s"
    
    # Image hinzufügen
    trivy_cmd="$trivy_cmd $image"
    
    echo -e "${MAGENTA}Detailliertes Scan-Ergebnis für $image:${NC}"
    echo "----------------------------------------"
    $trivy_cmd 2>/dev/null || echo "Scan fehlgeschlagen"
    echo
}

# Hauptscan-Funktion
perform_vulnerability_scan() {
    local vulnerability="$1"
    local namespace="$2"
    local severity="$3"
    local output_format="$4"
    local verbose="$5"
    local quiet="$6"
    local no_progress="$7"
    local timeout="$8"
    
    log_info "Starte Vulnerability-Scan für: $vulnerability"
    if [[ "$namespace" != "all" ]]; then
        log_info "Namespace: $namespace"
    else
        log_info "Namespace: Alle"
    fi
    
    # Container-Images extrahieren
    local images
    if ! images=$(get_container_images "$namespace" "$verbose"); then
        log_error "Konnte keine Container-Images extrahieren"
        exit 1
    fi
    
    if [[ -z "$images" ]]; then
        log_warn "Keine Container-Images gefunden"
        exit 0
    fi
    
    local image_count
    image_count=$(echo "$images" | wc -l)
    log_info "Gefundene Images: $image_count"
    
    # Counters
    local scanned=0
    local vulnerable=0
    local failed=0
    local safe=0
    
    # Durch alle Images iterieren
    while IFS= read -r image; do
        [[ -z "$image" ]] && continue
        
        ((scanned++))
        
        if [[ "$quiet" == "false" ]]; then
            log_info "Scanne Image ($scanned/$image_count): $image"
        fi
        
        # Image scannen
        local scan_result
        if scan_result=$(scan_image "$image" "$vulnerability" "$severity" "$output_format" "$verbose" "$timeout" "$no_progress"); then
            # Prüfen ob vulnerable
            if is_vulnerable "$scan_result" "$vulnerability"; then
                ((vulnerable++))
                log_vuln "$image ist vulnerable!"
                
                if [[ "$verbose" == "true" ]] || [[ "$output_format" != "table" ]]; then
                    show_detailed_scan "$image" "$vulnerability" "$severity" "$output_format" "$timeout" "$no_progress"
                fi
            else
                ((safe++))
                if [[ "$quiet" == "false" ]]; then
                    log_safe "$image ist sicher"
                fi
            fi
        else
            ((failed++))
            log_error "Scan fehlgeschlagen für: $image"
        fi
        
    done <<< "$images"
    
    # Zusammenfassung
    echo
    log_info "=== Scan-Zusammenfassung ==="
    log_info "Gescannte Images: $scanned"
    log_success "Sichere Images: $safe"
    if [[ $vulnerable -gt 0 ]]; then
        log_vuln "Vulnerable Images: $vulnerable"
    fi
    if [[ $failed -gt 0 ]]; then
        log_error "Fehlgeschlagene Scans: $failed"
    fi
    
    # Exit-Code basierend auf Ergebnissen
    if [[ $vulnerable -gt 0 ]]; then
        exit 2  # Vulnerabilities gefunden
    elif [[ $failed -gt 0 ]]; then
        exit 1  # Scan-Fehler
    else
        exit 0  # Alles sicher
    fi
}

# Hauptfunktion
main() {
    local vulnerability=""
    local namespace="all"
    local severity="CRITICAL"
    local output_format="table"
    local verbose="false"
    local quiet="false"
    local no_progress="false"
    local timeout="300"
    
    # Argumentverarbeitung
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -n|--namespace)
                namespace="$2"
                shift 2
                ;;
            -s|--severity)
                severity="$2"
                shift 2
                ;;
            -o|--output)
                output_format="$2"
                shift 2
                ;;
            -v|--verbose)
                verbose="true"
                shift
                ;;
            -q|--quiet)
                quiet="true"
                shift
                ;;
            --no-progress)
                no_progress="true"
                shift
                ;;
            --timeout)
                timeout="$2"
                shift 2
                ;;
            -*)
                log_error "Unbekannte Option: $1"
                echo "Verwendung: $0 <cve-id> [options]"
                exit 1
                ;;
            *)
                if [[ -z "$vulnerability" ]]; then
                    vulnerability="$1"
                else
                    log_error "Mehrere Vulnerabilities angegeben. Nur eine erlaubt."
                    exit 1
                fi
                shift
                ;;
        esac
    done
    
    # Vulnerability-Parameter prüfen
    if [[ -z "$vulnerability" ]]; then
        log_error "CVE-ID oder Vulnerability-Name erforderlich"
        echo "Verwendung: $0 <cve-id> [options]"
        echo "Für Hilfe: $0 --help"
        exit 1
    fi
    
    # Severity validieren
    case "$severity" in
        LOW|MEDIUM|HIGH|CRITICAL) ;;
        *) 
            log_error "Ungültige Severity: $severity"
            log_info "Gültige Werte: LOW, MEDIUM, HIGH, CRITICAL"
            exit 1
            ;;
    esac
    
    # Output-Format validieren
    case "$output_format" in
        table|json|sarif) ;;
        *) 
            log_error "Ungültiges Output-Format: $output_format"
            log_info "Gültige Werte: table, json, sarif"
            exit 1
            ;;
    esac
    
    # Timeout validieren
    if [[ ! "$timeout" =~ ^[0-9]+$ ]] || [[ "$timeout" -lt 10 ]]; then
        log_error "Ungültiger Timeout: $timeout (mindestens 10 Sekunden)"
        exit 1
    fi
    
    log_info "Kubernetes Vulnerability Scanner gestartet"
    
    # Abhängigkeiten prüfen
    check_dependencies
    
    # Kubernetes-Zugriff prüfen
    check_k8s_access
    
    # Scan durchführen
    perform_vulnerability_scan "$vulnerability" "$namespace" "$severity" "$output_format" "$verbose" "$quiet" "$no_progress" "$timeout"
}

# Script ausführen
main "$@"