#!/usr/bin/env bash

# Script: sanitize-text
# Zweck: Säubert Text-Dateien von speziellen Unicode-Zeichen und vereinheitlicht Formatierung
# Verwendung: ./sanitize-text INPUT [OUTPUT] [OPTIONEN]

set -euo pipefail

# Farben für Output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'  # No Color

# Globale Variablen
VERBOSE=false
INPUT_FILE=""
OUTPUT_FILE=""

# Funktionen für farbigen Output
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1" >&2
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

log_verbose() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo -e "${BLUE}[VERBOSE]${NC} $1" >&2
    fi
}

# Hilfe anzeigen
show_help() {
    cat << EOF
sanitize-text - Text Sanitizer

VERWENDUNG:
    $0 INPUT [OUTPUT] [OPTIONEN]

BESCHREIBUNG:
    Säubert Text-Dateien von speziellen Unicode-Zeichen, vereinheitlicht
    Leerzeichen und typografische Zeichen, und behält dabei Umlaute und
    Emojis bei. Ideal für die Bereinigung von kopierten Texten.

ARGUMENTE:
    INPUT                    Eingabe-Datei
    OUTPUT                   Ausgabe-Datei (optional, Standard: INPUT.cleaned.txt)

OPTIONEN:
    -v, --verbose            Detaillierte Ausgabe
    -h, --help               Diese Hilfe anzeigen

BEISPIELE:
    # Standard-Verwendung (Ausgabe: input.cleaned.txt)
    $0 input.txt

    # Mit spezifischer Ausgabedatei
    $0 input.txt output.txt

    # Mit detaillierter Ausgabe
    $0 input.txt --verbose

FUNKTIONEN:
    - Vereinheitlicht verschiedene Space-Varianten (NBSP, etc.) zu normalem Space
    - Konvertiert smarte Quotes und typografische Striche zu ASCII
    - Behält Emojis bei
    - Behält Umlaute und Akzentbuchstaben bei (äöüÄÖÜ, etc.)
    - Ersetzt Währungssymbole (€ → EUR, £ → GBP, etc.)
    - Ersetzt ß → ss
    - Kollabiert mehrfache Leerzeichen zu einem
    - Entfernt führende und trailing Leerzeichen pro Zeile

VORAUSSETZUNGEN:
    - Python 3.6+ muss installiert sein

HINWEISE:
    - Die Zeilenstruktur bleibt erhalten
    - UTF-8 Encoding wird verwendet
    - Emojis und ZWJ-Sequenzen bleiben erhalten
    - Lateinische Sonderzeichen (Umlaute, Akzente) bleiben erhalten
EOF
}

# Abhängigkeiten prüfen
check_dependencies() {
    local missing_deps=()

    if ! command -v python3 &> /dev/null; then
        missing_deps+=("python3")
    fi

    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_error "Fehlende Abhängigkeiten: ${missing_deps[*]}"
        log_info "Installation:"
        log_info "  macOS: brew install python3"
        log_info "  Linux: apt install python3 oder yum install python3"
        return 1
    fi

    # Python-Version prüfen
    local py_version
    py_version=$(python3 -c 'import sys; print(".".join(map(str, sys.version_info[:2])))' 2>/dev/null || echo "0.0")
    local major minor
    IFS='.' read -r major minor <<< "$py_version"

    if [[ "$major" -lt 3 ]] || [[ "$major" -eq 3 && "$minor" -lt 6 ]]; then
        log_error "Python 3.6+ erforderlich (gefunden: $py_version)"
        return 1
    fi

    log_verbose "Python-Version: $py_version"
    return 0
}

# Parameter parsen
parse_arguments() {
    local positional_args=()

    while [[ $# -gt 0 ]]; do
        case $1 in
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            -*)
                log_error "Unbekannte Option: $1"
                show_help
                exit 1
                ;;
            *)
                positional_args+=("$1")
                shift
                ;;
        esac
    done

    # Positional-Parameter setzen
    if [[ ${#positional_args[@]} -lt 1 ]]; then
        log_error "Zu wenige Argumente"
        show_help
        exit 1
    fi

    INPUT_FILE="${positional_args[0]}"

    if [[ ! -f "$INPUT_FILE" ]]; then
        log_error "Eingabedatei nicht gefunden: $INPUT_FILE"
        exit 1
    fi

    # Ausgabedatei bestimmen
    if [[ ${#positional_args[@]} -ge 2 ]]; then
        OUTPUT_FILE="${positional_args[1]}"
    else
        # Standard: <name>.cleaned.txt
        local base="${INPUT_FILE##*/}"
        local stem="${base%.*}"
        local dir="${INPUT_FILE%/*}"

        if [[ "$INPUT_FILE" != */* ]]; then
            OUTPUT_FILE="${stem}.cleaned.txt"
        else
            OUTPUT_FILE="${dir}/${stem}.cleaned.txt"
        fi
    fi
}

# Hauptlogik
main() {
    # Abhängigkeiten prüfen
    if ! check_dependencies; then
        exit 2
    fi

    # Parameter parsen
    parse_arguments "$@"

    log_verbose "Eingabedatei: $INPUT_FILE"
    log_verbose "Ausgabedatei: $OUTPUT_FILE"
    log_info "Säubere Text-Datei ..."

    # Python-Script ausführen
    python3 - "$INPUT_FILE" "$OUTPUT_FILE" <<'PY'
import sys, unicodedata, re, io, os

inf, outf = sys.argv[1], sys.argv[2]

def replace_special_spaces(s: str) -> str:
    # Verschiedene Space-Varianten -> normales Space
    space_like = {
        "\u00A0",  # NBSP
        "\u202F",  # NARROW NBSP
        "\u2007",  # FIGURE SPACE
        "\u2008",  # PUNCTUATION SPACE
        "\u2009",  # THIN SPACE
        "\u200A",  # HAIR SPACE
        "\u2002", "\u2003", "\u2004", "\u2005", "\u2006",  # EN/EM/THREE-PER-EM etc.
        "\u205F",  # MEDIUM MATHEMATICAL SPACE
        "\u3000",  # IDEOGRAPHIC SPACE
        "\u180E",  # MONGOLIAN VOWEL SEPARATOR (als Space behandeln)
        "\u2000", "\u2001",  # weitere Spaces
    }
    for ch in space_like:
        s = s.replace(ch, " ")
    return s

def map_typography(s: str) -> str:
    # Smarte Quotes / Striche -> ASCII
    replacements = {
        "\u2018": "'", "\u2019": "'", "\u201A": "'", "\u201B": "'",
        "\u201C": '"', "\u201D": '"', "\u201E": '"', "\u00AB": '"', "\u00BB": '"',
        "\u2032": "'", "\u2033": '"',
        "\u2013": "-", "\u2014": "-", "\u2212": "-",  # en dash, em dash, minus
    }
    return s.translate(str.maketrans(replacements))

# Emojis & relevante Kombinatoren beibehalten
def is_emoji_cp(cp: int) -> bool:
    return (
        0x1F300 <= cp <= 0x1FAFF or  # diverse Emojis/Symbole
        0x1F900 <= cp <= 0x1F9FF or
        0x2600  <= cp <= 0x27BF  or  # Misc symbols, Dingbats
        0x1F1E6 <= cp <= 0x1F1FF or  # Flaggen (Regional Indicators)
        0x1F3FB <= cp <= 0x1F3FF or  # Hauttöne
        cp in (0x200D, 0xFE0F)       # ZWJ & Variation Selector
    )

# Buchstaben mit spezieller Transliteration
special_letter_map = {
    "ß": "ss",
    "Æ": "AE", "æ": "ae",
    "Ø": "O",  "ø": "o",
    "Đ": "D",  "đ": "d",
    "Ł": "L",  "ł": "l",
    "Þ": "Th", "þ": "th",
    "Œ": "OE", "oe": "oe", "Œ": "OE", "œ": "oe",
}

# Häufige Währungen -> ASCII
symbol_map = {
    "€": "EUR", "£": "GBP", "¥": "JPY", "₩": "KRW", "₽": "RUB",
    "₹": "INR", "₿": "BTC", "¢": "c",
}

def ascii_sanitise(text: str) -> str:
    # 1) Unicode-Kompatibilitätsnormalisierung (komponiert i. d. R. zu NFC)
    text = unicodedata.normalize("NFKC", text)
    # 2) Typografie vereinheitlichen
    text = map_typography(text)
    # 3) Spezielle Spaces vereinheitlichen
    text = replace_special_spaces(text)

    out = []
    for ch in text:
        cp = ord(ch)

        # ASCII direkt
        if 0x20 <= cp <= 0x7E or ch in "\n\r\t":
            out.append(ch)
            continue

        # Emojis & relevante Modifikatoren behalten
        if is_emoji_cp(cp):
            out.append(ch)
            continue

        # Währungssymbole & Sondertransliteration
        if ch in symbol_map:
            out.append(symbol_map[ch])
            continue
        if ch in special_letter_map:
            out.append(special_letter_map[ch])
            continue

        # Gängige lateinische Bereiche BEIBEHALTEN (Umlaute/Akzentbuchstaben etc.)
        # Latin-1 Supplement, Latin Extended-A, Latin Extended-B
        if (0x00C0 <= cp <= 0x024F) or ch in ("\u00E4","\u00F6","\u00FC","\u00C4","\u00D6","\u00DC"):
            out.append(ch)
            continue

        # Sonst vereinfachen: Diakritika entfernen und nur ASCII behalten
        nfd = unicodedata.normalize("NFD", ch)
        stripped = "".join(c for c in nfd if unicodedata.category(c) != "Mn")

        ascii_only = []
        for c in stripped:
            if 0x20 <= ord(c) <= 0x7E:
                ascii_only.append(c)
        out.append("".join(ascii_only))
    return "".join(out)

def collapse_spaces_keep_lines(text: str) -> str:
    # Pro Zeile: Mehrfach-Spaces/Tabs -> 1 Space; führende/trailing Spaces entfernen.
    # Zeilenstruktur bleibt erhalten.
    lines = text.splitlines(keepends=False)
    norm = []
    for ln in lines:
        ln = re.sub(r"[ \t]+", " ", ln)
        ln = ln.strip()
        norm.append(ln)
    # ursprünglichen finalen Zeilenumbruch beibehalten (falls vorhanden)
    return "\n".join(norm) + ("\n" if text.endswith(("\n", "\r", "\r\n")) else "")

with io.open(inf, "r", encoding="utf-8", errors="strict") as f:
    raw = f.read()

clean = ascii_sanitise(raw)
clean = collapse_spaces_keep_lines(clean)

with io.open(outf, "w", encoding="utf-8", newline="") as f:
    f.write(clean)

print(f"Wrote cleaned text to: {os.path.abspath(outf)}")
PY

    if [[ $? -eq 0 ]]; then
        log_success "Text erfolgreich gesäubert"
        log_info "Ausgabe: $OUTPUT_FILE"
        exit 0
    else
        log_error "Fehler beim Säubern der Datei"
        exit 3
    fi
}

# Script-Ausführung
main "$@"
